/*
 * Copyright 2018 evove.tech
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
def defaults = loadDefaults()
def app = defaults.app
def pom = defaults.pom
app.plugins = [
        'org.gradle.kotlin.kotlin-dsl': [
                version: app.kotlinDslVersion
        ],
        'kotlin': [
                module: 'org.jetbrains.kotlin:kotlin-gradle-plugin',
                version: app.kotlinVersion
        ],
        'com.android': [
                module: "com.android.tools.build:gradle",
                version: app.androidGradleVersion
        ],
        'realm': [
                module: 'io.realm:realm-gradle-plugin',
                version: app.realmVersion
        ],
        'io.fabric': [
                module: 'io.fabric.tools:gradle',
                version: app.fabricVersion
        ],
        'com.google.firebase': [
                module: 'com.google.firebase:firebase-plugins',
                version: app.firebasePluginsVersion
        ],
        'com.jfrog.bintray': [
                module: 'com.jfrog.bintray.gradle:gradle-bintray-plugin',
                version: app.gradleBintrayPluginVersion
        ],
        'evovetech': [
                version: pom.version
        ],
        'com.jfrog.artifactory': [
                version: '4.7.1'
        ]
]
app.repos = {
    mavenLocal()
    google()
    jcenter()
    maven { url 'https://maven.fabric.io/public' }
}
app.configurePlugins = { PluginManagementSpec plug ->
    Closure cl = {
        repositories {
            gradlePluginPortal()
        }
        repositories(app.repos)
        resolutionStrategy {
            eachPlugin {
                def found = false
                def reqId = requested.id.id
                app.plugins.find { String key, Map value ->
                    if (reqId.startsWith(key)) {
                        def module = value.get("module", null)
                        def version = value.get("version", null)
                        if (module && version) {
                            println("${reqId}: module=${module}, version=${version}")
                            useModule("${module}:${version}")
                        } else if (module) {
                            println("${reqId}: module=${module}, version=${requested.version}")
                            useModule("${module}:${requested.version}")
                        } else if (version) {
                            println("${reqId}: version=${version}")
                            useVersion(version)
                        }
                        found = true
                        return true
                    }
                    return false
                }
                if (!found) {
                    println("${reqId}: module=${module}, version=${requested.version}")
                }
            }
        }
    }
    cl.delegate = plug
    cl(plug)
}

gradle.rootProject { p ->
    settings.ext.properties.each { prop ->
        p.ext."${prop.key}" = prop.value
    }
    loadProject(p)

    p.buildscript.repositories(p.app.repos)
    task wrapper(type: Wrapper) {
        gradleVersion p.app.gradleVersion
        distributionType 'all'
    }
}

gradle.beforeProject { p ->
    loadProject(p)
    p.repositories(p.app.repos)
}

def loadDefaults() {
    def configDir = setConfigDir(settings)
    return [
            app: loadDefault(configDir, 'app'),
            pom: loadDefault(configDir, 'pom')
    ]
}

def loadDefault(configDir, String ext) {
    def expando = new Expando()
    loadProperties(this, "${configDir}/defaultGradle.properties", expando, "${ext}.")
    this.ext.set(ext, expando)
    return expando
}

static def setConfigDir(settings) {
    def gradle = settings.gradle
    println "try parent gradle config dir"
    def configDir = tryGetGradleConfigDir(gradle)
    if (configDir == null) {
        println "try normal config dir"
        configDir = tryGetConfigDir(settings.ext)
    }
    if (configDir == null) {
        println "default config dir"
        configDir = "${settings.settingsDir}/gradle"
    }
    settings.gradle.ext.configDir = configDir
    settings.ext.configDir = configDir
    return configDir
}

static def tryGetGradleConfigDir(gradle) {
    def gp = gradle.parent
    if (gp != null) {
        println "gp = ${gp}"
        def configDir = tryGetGradleConfigDir(gp)
        if (configDir != null) {
            return configDir
        }
    }
    return tryGetConfigDir(gradle.ext)
}

static def tryGetConfigDir(ext) {
    if (ext.has('configDir')) {
        println "returning configDir: ${ext.configDir}"
        return ext.configDir
    }
    return null
}

static def loadProject(p) {
    File propsFile = p.file('gradle.properties')
    def app = new Expando(p.app.properties)
    p.ext.app = app
    loadProperties(p, propsFile, app, 'app.')
    def pom = new Expando(p.pom.properties)
    p.ext.pom = pom
    loadProperties(p, propsFile, pom, 'pom.')
}

static def loadProperties(p, fileName, obj, objPrefix) {
    def file = p.file(fileName)
    if (!file.exists()) {
        return
    }
    def props = new Properties()
    props.load(file.newReader())
    props.each { prop ->
        def key = prop.key as String
        if (key.startsWith(objPrefix)) {
            key = key.substring(objPrefix.length())
            obj."${key}" = prop.value
        }
    }
}
